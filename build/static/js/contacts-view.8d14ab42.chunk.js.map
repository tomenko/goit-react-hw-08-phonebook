{"version":3,"sources":["../node_modules/nanoid/index.browser.js","components/ContactForm/ContactForm.jsx","components/ContactList/ContactList.jsx","components/ContactItem/ContactItem.jsx","components/Filter/Filter.jsx","views/ContactsView.js"],"names":["nanoid","size","id","bytes","crypto","getRandomValues","Uint8Array","byte","toString","toUpperCase","ContactForm","state","name","number","loginInputNameId","loginInputNamberId","hendleInputChange","event","currentTarget","value","setState","handleSubmit","preventDefault","props","items","some","contact","alert","onSubmit","reset","this","className","htmlFor","type","pattern","title","required","onChange","Component","connect","getItems","dispatch","addContact","ContactList","children","contactsItems","getFilteredContactList","onDelete","deleteContact","map","onClick","getFilterValue","changeFilter","target","ContactsView","fetchItems","length","isLoading","getLoadingItems","fetchContacts"],"mappings":"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","file":"static/js/contacts-view.8d14ab42.chunk.js","sourcesContent":["// This file replaces `index.js` in bundlers like webpack or Rollup,\n// according to `browser` config in `package.json`.\n\nimport { urlAlphabet } from './url-alphabet/index.js'\n\nif (process.env.NODE_ENV !== 'production') {\n  // All bundlers will remove this block in the production bundle.\n  if (\n    typeof navigator !== 'undefined' &&\n    navigator.product === 'ReactNative' &&\n    typeof crypto === 'undefined'\n  ) {\n    throw new Error(\n      'React Native does not have a built-in secure random generator. ' +\n        'If you don’t need unpredictable IDs use `nanoid/non-secure`. ' +\n        'For secure IDs, import `react-native-get-random-values` ' +\n        'before Nano ID.'\n    )\n  }\n  if (typeof msCrypto !== 'undefined' && typeof crypto === 'undefined') {\n    throw new Error(\n      'Import file with `if (!window.crypto) window.crypto = window.msCrypto`' +\n        ' before importing Nano ID to fix IE 11 support'\n    )\n  }\n  if (typeof crypto === 'undefined') {\n    throw new Error(\n      'Your browser does not have secure random generator. ' +\n        'If you don’t need unpredictable IDs, you can use nanoid/non-secure.'\n    )\n  }\n}\n\nlet random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\n\nlet customRandom = (alphabet, size, getRandom) => {\n  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes\n  // values closer to the alphabet size. The bitmask calculates the closest\n  // `2^31 - 1` number, which exceeds the alphabet size.\n  // For example, the bitmask for the alphabet size 30 is 31 (00011111).\n  // `Math.clz32` is not used, because it is not available in browsers.\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  // Though, the bitmask solution is not perfect since the bytes exceeding\n  // the alphabet size are refused. Therefore, to reliably generate the ID,\n  // the random bytes redundancy has to be satisfied.\n\n  // Note: every hardware random generator call is performance expensive,\n  // because the system call for entropy collection takes a lot of time.\n  // So, to avoid additional system calls, extra bytes are requested in advance.\n\n  // Next, a step determines how many random bytes to generate.\n  // The number of random bytes gets decided upon the ID size, mask,\n  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance\n  // according to benchmarks).\n\n  // `-~f => Math.ceil(f)` if f is a float\n  // `-~i => i + 1` if i is an integer\n  let step = -~((1.6 * mask * size) / alphabet.length)\n\n  return () => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      // A compact alternative for `for (var i = 0; i < step; i++)`.\n      let j = step\n      while (j--) {\n        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\n\nlet customAlphabet = (alphabet, size) => customRandom(alphabet, size, random)\n\nlet nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array(size))\n\n  // A compact alternative for `for (var i = 0; i < step; i++)`.\n  while (size--) {\n    // It is incorrect to use bytes exceeding the alphabet size.\n    // The following mask reduces the random byte in the 0-255 value\n    // range to the 0-63 value range. Therefore, adding hacks, such\n    // as empty string fallback or magic numbers, is unneccessary because\n    // the bitmask trims bytes down to the alphabet size.\n    let byte = bytes[size] & 63\n    if (byte < 36) {\n      // `0-9a-z`\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      // `A-Z`\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte < 63) {\n      id += '_'\n    } else {\n      id += '-'\n    }\n  }\n  return id\n}\n\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n","import React, { Component } from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { addContact, getItems } from '../../redux/contacts';\r\nimport PropTypes from 'prop-types';\r\nimport { nanoid } from 'nanoid'\r\n\r\nclass ContactForm extends Component {\r\n  static propTypes = {\r\n    name: PropTypes.string,\r\n    number: PropTypes.string,\r\n  };\r\n\r\n  state = {\r\n    name: '',\r\n    number: '',\r\n  };\r\n    \r\n  loginInputNameId = nanoid(); \r\n  loginInputNamberId = nanoid(); \r\n  \r\n  hendleInputChange = event => {\r\n    const { name, value } = event.currentTarget;\r\n\r\n    this.setState({ [name]: value });\r\n  };\r\n\r\n  handleSubmit = event => {\r\n    event.preventDefault();\r\n\r\n    const addInputValue = contact =>\r\n      contact.name === this.state.name || contact.number === this.state.number;\r\n\r\n    if (this.props.items.some(addInputValue)) {\r\n      alert(`Contact is already in contacts`);\r\n      return;\r\n    }\r\n\r\n    this.props.onSubmit({...this.state})\r\n    this.reset()\r\n  };\r\n    \r\n  reset = () => {\r\n    this.setState({ name: '', number: '' })\r\n  };\r\n  \r\n  render() {\r\n    const { name, number } = this.state;\r\n      \r\n    return (\r\n      <section className=\"sectionFormContacts\">\r\n        <form onSubmit = {this.handleSubmit}>\r\n          <label htmlFor={this.loginInputNameId}>Name</label>\r\n          \r\n          <input\r\n            type=\"text\"\r\n            name=\"name\"\r\n            pattern=\"^[a-zA-Zа-яА-Я]+(([' -][a-zA-Zа-яА-Я ])?[a-zA-Zа-яА-Я]*)*$\"\r\n            title=\"Имя может состоять только из букв, апострофа, тире и пробелов. Например Adrian, Jacob Mercer, Charles de Batz de Castelmore d'Artagnan и т. п.\"\r\n            required\r\n            id = {this.loginInputNameId}\r\n            value={name}\r\n            onChange = {this.hendleInputChange}\r\n                \r\n          />\r\n        \r\n\r\n          <label htmlFor={this.loginInputNamberId}>Number</label>\r\n          \r\n          <input\r\n            type=\"tel\"\r\n            name=\"number\"\r\n            pattern=\"\\+?\\d{1,4}?[-.\\s]?\\(?\\d{1,3}?\\)?[-.\\s]?\\d{1,4}[-.\\s]?\\d{1,4}[-.\\s]?\\d{1,9}\"\r\n            title=\"Номер телефона должен состоять из цифр и может содержать пробелы, тире, круглые скобки и может начинаться с +\"\r\n            required\r\n            id = {this.loginInputNamberId}\r\n            value={number}\r\n            onChange = {this.hendleInputChange}\r\n          />\r\n        \r\n                  \r\n          <button type=\"submit\" className=\"btn btnForm\">Add contact</button>\r\n        </form>\r\n      </section>\r\n\r\n    )\r\n  }\r\n}\r\n\r\nconst mapStateToProps = state => ({\r\n  items: getItems(state),\r\n});\r\n\r\nconst mapDispatchFromProps = dispatch => ({\r\n  onSubmit: ({ name, number }) => dispatch(addContact({ name, number })),\r\n});\r\n\r\nexport default connect(mapStateToProps, mapDispatchFromProps)(ContactForm);\r\n","import PropTypes from 'prop-types';\r\n\r\nconst ContactList = ({ children }) => (\r\n  <ul className=\"contactList\">{children}</ul>\r\n);\r\n\r\nContactList.propTypes = {\r\n  children: PropTypes.node,\r\n};\r\n\r\nexport default ContactList;\r\n\r\n","import PropTypes from 'prop-types';\r\nimport { connect } from 'react-redux';\r\nimport { deleteContact, getFilteredContactList } from '../../redux/contacts';\r\n\r\nconst ContactItem = ({ onDelete, contactsItems }) => (\r\n  <>\r\n    {contactsItems.map(({ id, name, number }) => {\r\n      return (\r\n        <li key={id}>\r\n          <p>{`${name}: ${number}`}</p>\r\n          <button type=\"button\" onClick={() => onDelete(id)} className=\"btn\">\r\n            Delete\r\n          </button>\r\n        </li>\r\n      );\r\n    })}\r\n  </>\r\n);\r\n\r\nconst mapStateToProps = state => ({\r\n  contactsItems: getFilteredContactList(state),\r\n});\r\n\r\nconst mapDispatchFromProps = dispatch => ({\r\n  onDelete: id => dispatch(deleteContact(id)),\r\n});\r\n\r\nexport default connect(mapStateToProps, mapDispatchFromProps)(ContactItem);\r\n\r\n\r\nContactItem.propTypes = {\r\n  contacts: PropTypes.arrayOf(\r\n    PropTypes.shape({\r\n      id: PropTypes.string.isRequired,\r\n      name: PropTypes.string.isRequired,\r\n      number: PropTypes.string.isRequired,\r\n    }),\r\n  ),\r\n  onDelete: PropTypes.func,\r\n};","import { connect } from 'react-redux';\r\nimport { changeFilter, getFilterValue } from '../../redux/contacts';\r\n\r\nconst Filter = ({ value, onChange }) => (\r\n  <label className=\"filter\">\r\n    Find contacts by name\r\n    <div >\r\n      <input type=\"text\" value={value} onChange={onChange}></input>\r\n    </div>\r\n    \r\n  </label>\r\n);\r\n\r\nconst mapStateToProps = state => ({\r\n  value: getFilterValue(state),\r\n});\r\n\r\nconst mapDispatchFromProps = dispatch => ({\r\n  onChange: event => dispatch(changeFilter(event.target.value)),\r\n});\r\n\r\nexport default connect(mapStateToProps, mapDispatchFromProps)(Filter);\r\n\r\n","import React, {Component} from 'react';\r\nimport { connect, } from 'react-redux';\r\n\r\nimport ContactForm from '../components/ContactForm'\r\nimport ContactList from '../components/ContactList'\r\nimport ContactItem from '../components/ContactItem';\r\nimport Filter from '../components/Filter'\r\n\r\nimport { fetchContacts } from '../redux/contacts/contacts-operations';\r\nimport { getItems, getLoadingItems } from '../redux/contacts/contacts-selectors';\r\n\r\nclass ContactsView extends Component {\r\n  componentDidMount() {\r\n    this.props.fetchItems();\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <>\r\n        <h1>Phonebook</h1>\r\n        <ContactForm/>\r\n        <h2>Contacts</h2>\r\n  \r\n        {this.props.items.length > 0 ? (\r\n          <>\r\n            <Filter />\r\n            <ContactList>\r\n              <ContactItem />\r\n            </ContactList>\r\n          </>\r\n        ) : (\r\n          <span>You have no contacts!</span>\r\n        )}\r\n      </>\r\n    )\r\n  }\r\n};\r\n\r\n\r\nconst mapStateToProps = state => ({\r\n  items: getItems(state),\r\n  isLoading: getLoadingItems(state),\r\n});\r\n\r\nconst mapDispatchToProps = dispatch => ({\r\n  fetchItems: () => dispatch(fetchContacts()),\r\n});\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(ContactsView);"],"sourceRoot":""}